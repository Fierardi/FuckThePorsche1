<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>MoneyFactory - Polished Edition</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
  
  * {
    box-sizing: border-box;
  }
  
  body {
    margin: 0;
    background: linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 50%, #16213e 100%);
    font-family: 'Orbitron', monospace;
    color: white;
    display: flex;
    flex-direction: column;
    align-items: center;
    min-height: 100vh;
    overflow-x: hidden;
  }
  
  /* Animated background particles */
  .bg-particles {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: -1;
  }
  
  .particle {
    position: absolute;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 50%;
    animation: float 6s ease-in-out infinite;
  }
  
  @keyframes float {
    0%, 100% { transform: translateY(0px) rotate(0deg); opacity: 0.1; }
    50% { transform: translateY(-20px) rotate(180deg); opacity: 0.3; }
  }
  
  h1 {
    margin: 20px 0;
    font-size: 3rem;
    font-weight: 900;
    text-align: center;
    background:  #f7df5c;
    background-size: 300% 300%;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    animation: gradientShift 3s ease-in-out infinite;
    text-shadow: 0 0 30px rgba(255, 255, 255, 0.3);
  }
  
  @keyframes gradientShift {
    0%, 100% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
  }
  
  #gameArea {
    display: flex;
    flex-direction: row;
    align-items: flex-start;
    justify-content: center;
    gap: 40px;
    padding: 20px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 20px;
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
  }
  
  canvas {
    border: 2px solid rgba(0, 212, 255, 0.3);
    background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
    cursor: crosshair;
    border-radius: 15px;
    box-shadow: 0 10px 30px rgba(0, 212, 255, 0.2);
    transition: box-shadow 0.3s ease;
  }
  
  canvas:hover {
    box-shadow: 0 15px 40px rgba(0, 212, 255, 0.4);
  }
  
  #factoryIconWrapper {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
    gap: 15px;
  }
  
  .factory-section {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 15px;
    padding: 20px;
    border: 1px solid rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(5px);
    transition: all 0.3s ease;
  }
  
  .factory-section:hover {
    background: rgba(255, 255, 255, 0.08);
    transform: translateY(-2px);
  }
  
  .iconBox {
    width: 90px;
    height: 90px;
    font-size: 3.5rem;
    display: flex;
    align-items: center;
    justify-content: center;
    background: linear-gradient(135deg, #ff6b00, #ff8e53);
    color: white;
    border: 2px solid rgba(255, 255, 255, 0.2);
    border-radius: 15px;
    cursor: grab;
    user-select: none;
    margin-bottom: 10px;
    transition: all 0.3s ease;
    box-shadow: 0 5px 15px rgba(255, 107, 0, 0.3);
    position: relative;
    overflow: hidden;
  }
  
  .iconBox::before {
    content: '';
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.1), transparent);
    transform: rotate(45deg);
    transition: all 0.6s ease;
    opacity: 0;
  }
  
  .iconBox:hover::before {
    animation: shine 0.6s ease-in-out;
  }
  
  @keyframes shine {
    0% { transform: translateX(-100%) translateY(-100%) rotate(45deg); opacity: 0; }
    50% { opacity: 1; }
    100% { transform: translateX(100%) translateY(100%) rotate(45deg); opacity: 0; }
  }
  
  .iconBox:hover {
    transform: translateY(-3px) scale(1.05);
    box-shadow: 0 8px 25px rgba(255, 107, 0, 0.5);
  }
  
  .iconBox:active {
    cursor: grabbing;
    transform: scale(0.95);
  }
  
  .iconBox[data-type="central"] {
    background: linear-gradient(135deg, #e74c3c, #c0392b);
    box-shadow: 0 5px 15px rgba(231, 76, 60, 0.3);
  }
  
  .iconBox[data-type="central"]:hover {
    box-shadow: 0 8px 25px rgba(231, 76, 60, 0.5);
  }
  
  .factoryCost {
    font-size: 1.1rem;
    color: #00d4ff;
    font-weight: 700;
    text-align: center;
    text-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
  }
  
  .insufficient-funds {
    color: #ff4757 !important;
    animation: pulse 1s ease-in-out infinite;
  }
  
  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
  }
  
  #info {
    margin-top: 30px;
    margin-bottom: 30px;
    font-size: 2rem;
    font-weight: 700;
    text-align: center;
    background: rgba(255, 255, 255, 0.1);
    padding: 15px 30px;
    border-radius: 50px;
    border: 2px solid rgba(255, 255, 255, 0.2);
    backdrop-filter: blur(10px);
    color: #00d4ff;
    text-shadow: 0 0 20px rgba(0, 212, 255, 0.5);
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
    transition: all 0.3s ease;
  }
  
  #info:hover {
    transform: scale(1.05);
    box-shadow: 0 15px 40px rgba(0, 212, 255, 0.3);
  }
  
  .notification {
    position: fixed;
    top: 20px;
    right: 20px;
    background: rgba(255, 71, 87, 0.95);
    color: white;
    padding: 15px 25px;
    border-radius: 10px;
    font-weight: 700;
    z-index: 1000;
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.2);
    animation: slideIn 0.3s ease forwards, fadeOut 0.6s ease 2s forwards;
  }
  
  @keyframes slideIn {
    from { transform: translateX(100%); opacity: 0; }
    to { transform: translateX(0); opacity: 1; }
  }
  
  @keyframes fadeOut {
    to { opacity: 0; }
  }
</style>
</head>
<body>

<h1>MoneyFactory</h1>

<div id="gameArea">
  <canvas id="factoryGrid" width="700" height="700" tabindex="0"></canvas>

  <div id="factoryIconWrapper">
    <section class="factory-section">
      <div class="iconBox" draggable="true" data-type="standard" title="Standard Factory (Cost: 50)">üè≠</div>
      <div class="factoryCost" id="costStandard">Cost: 50 Coins</div>
    </section>

    <section class="factory-section">
      <div class="iconBox" draggable="true" data-type="central" title="Central Factory (Cost: 100)">üè∞</div>
      <div class="factoryCost" id="costCentral">Cost: 100 Coins</div>
    </section>
  </div>
</div>

<div id="info">Coins: 0</div>

<div class="bg-particles" id="bgParticles"></div>

<script>
  // Animated background particles
  (() => {
    const container = document.getElementById('bgParticles');
    const particleCount = 40;
    const colors = ['rgba(255,255,255,0.05)', 'rgba(0,212,255,0.1)', 'rgba(255,255,255,0.1)'];

    for (let i = 0; i < particleCount; i++) {
      const particle = document.createElement('div');
      particle.className = 'particle';
      const size = Math.random() * 6 + 2;
      particle.style.width = size + 'px';
      particle.style.height = size + 'px';
      particle.style.left = Math.random() * window.innerWidth + 'px';
      particle.style.top = Math.random() * window.innerHeight + 'px';
      particle.style.background = colors[Math.floor(Math.random() * colors.length)];
      particle.style.animationDelay = (Math.random() * 6) + 's';
      particle.style.animationDuration = (5 + Math.random() * 6) + 's';
      container.appendChild(particle);
    }
  })();

  // Game logic
  const canvas = document.getElementById('factoryGrid');
  const ctx = canvas.getContext('2d');
  const gridSize = 10;
  const cellSize = canvas.width / gridSize;

  let coins = 0;
  const info = document.getElementById('info');

  // Factories placed on grid: {x, y, type}
  const factories = [];

  // Paths: array of points [{x,y},...]
  let paths = [];

  // Coins on paths: {positionIndex, offset}
  const coinsOnPath = [];

  // Factory costs
  const factoryCosts = {
    standard: 50,
    central: 100
  };

  // State for dragging factories from sidebar
  let draggingFactoryType = null;

  // State for placing factory on grid
  let isPlacingFactory = false;
  let placeX = 0;
  let placeY = 0;

  // State for drawing path
  let isDrawingPath = false;
  let pathDrawingPoints = [];

  // Coins follow speed (cells per second)
  const coinSpeed = 2;

  // Initialize coins count with some starting coins
  coins = 200;
  updateInfo();

  // Draw grid
  function drawGrid() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.strokeStyle = '#00d4ff33';
    ctx.lineWidth = 1;
    for (let i = 0; i <= gridSize; i++) {
      // Vertical lines
      ctx.beginPath();
      ctx.moveTo(i * cellSize, 0);
      ctx.lineTo(i * cellSize, canvas.height);
      ctx.stroke();
      // Horizontal lines
      ctx.beginPath();
      ctx.moveTo(0, i * cellSize);
      ctx.lineTo(canvas.width, i * cellSize);
      ctx.stroke();
    }
  }

  // Draw factories
  function drawFactories() {
    for (const f of factories) {
      const cx = f.x * cellSize + cellSize/2;
      const cy = f.y * cellSize + cellSize/2;
      ctx.save();
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.font = f.type === 'central' ? 'bold 36px Arial' : 'bold 30px Arial';
      ctx.shadowColor = f.type === 'central' ? '#e74c3c' : '#ff6b00';
      ctx.shadowBlur = 10;
      ctx.fillStyle = f.type === 'central' ? '#e74c3c' : '#ff6b00';
      ctx.fillText(f.type === 'central' ? 'üè∞' : 'üè≠', cx, cy);
      ctx.restore();
    }
  }

  // Draw paths
  function drawPaths() {
    if (paths.length < 2) return;
    ctx.strokeStyle = '#00d4ffaa';
    ctx.lineWidth = 4;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(paths[0].x * cellSize + cellSize/2, paths[0].y * cellSize + cellSize/2);
    for (let i = 1; i < paths.length; i++) {
      ctx.lineTo(paths[i].x * cellSize + cellSize/2, paths[i].y * cellSize + cellSize/2);
    }
    ctx.stroke();
  }

  // Draw coins on path
  function drawCoins(deltaTime) {
    if (coinsOnPath.length === 0 || paths.length < 2) return;

    const totalPathLength = getTotalPathLength();
    for (const coin of coinsOnPath) {
      // Update coin position on path
      coin.offset += (coinSpeed * deltaTime);
      if (coin.offset > totalPathLength) {
        coin.offset = 0;
      }

      // Find coin coordinates on path based on offset
      const pos = getPointOnPath(coin.offset);

      ctx.save();
      ctx.font = '24px Arial';
      ctx.shadowColor = '#ffff00';
      ctx.shadowBlur = 12;
      ctx.fillStyle = '#ffff00';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('üí∞', pos.x * cellSize + cellSize/2, pos.y * cellSize + cellSize/2);
      ctx.restore();
    }
  }

  // Calculate total path length (in grid cells)
  function getTotalPathLength() {
    let length = 0;
    for (let i = 1; i < paths.length; i++) {
      length += distance(paths[i-1], paths[i]);
    }
    return length;
  }

  // Linear interpolation along path given offset
  function getPointOnPath(offset) {
    let distLeft = offset;
    for (let i = 1; i < paths.length; i++) {
      const segLen = distance(paths[i-1], paths[i]);
      if (segLen >= distLeft) {
        const t = distLeft / segLen;
        return {
          x: paths[i-1].x + (paths[i].x - paths[i-1].x) * t,
          y: paths[i-1].y + (paths[i].y - paths[i-1].y) * t
        };
      }
      distLeft -= segLen;
    }
    // If offset exceeds path, return last point
    return paths[paths.length-1];
  }

  // Distance between two points on grid
  function distance(p1, p2) {
    return Math.sqrt((p1.x - p2.x)**2 + (p1.y - p2.y)**2);
  }

  // Check if a grid cell is empty (no factory)
  function isCellEmpty(x, y) {
    return !factories.some(f => f.x === x && f.y === y);
  }

  // Check if cell is within grid bounds
  function isValidCell(x, y) {
    return x >= 0 && y >= 0 && x < gridSize && y < gridSize;
  }

  // Handle drag & drop factories from sidebar
  document.querySelectorAll('.iconBox').forEach(icon => {
    icon.addEventListener('dragstart', e => {
      draggingFactoryType = e.target.dataset.type;
      e.dataTransfer.setData('text/plain', draggingFactoryType);
      // Add a drag image (optional)
      const dragIcon = document.createElement('canvas');
      dragIcon.width = dragIcon.height = 50;
      const dctx = dragIcon.getContext('2d');
      dctx.font = '40px Arial';
      dctx.textAlign = 'center';
      dctx.textBaseline = 'middle';
      dctx.fillText(draggingFactoryType === 'central' ? 'üè∞' : 'üè≠', 25, 25);
      e.dataTransfer.setDragImage(dragIcon, 25, 25);
    });
  });

  // Allow dropping on canvas
  canvas.addEventListener('dragover', e => {
    e.preventDefault();
  });

  // Place factory on drop
  canvas.addEventListener('drop', e => {
    e.preventDefault();
    if (!draggingFactoryType) return;

    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    const gridX = Math.floor(mouseX / cellSize);
    const gridY = Math.floor(mouseY / cellSize);

    if (!isValidCell(gridX, gridY)) return;

    if (!isCellEmpty(gridX, gridY)) {
      showNotification('Cell is occupied!');
      return;
    }

    const cost = factoryCosts[draggingFactoryType];
    if (coins < cost) {
      showNotification('Not enough coins!');
      return;
    }

    coins -= cost;
    updateInfo();

    factories.push({ x: gridX, y: gridY, type: draggingFactoryType });
    drawGame();

    draggingFactoryType = null;
  });

  // Drawing path logic (start on factory click, draw by dragging, end on release)
  canvas.addEventListener('mousedown', e => {
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    const gridX = Math.floor(mouseX / cellSize);
    const gridY = Math.floor(mouseY / cellSize);

    if (!isValidCell(gridX, gridY)) return;

    // Only start path drawing if clicked on a factory
    if (!factories.some(f => f.x === gridX && f.y === gridY)) return;

    isDrawingPath = true;
    pathDrawingPoints = [{ x: gridX, y: gridY }];
  });

  canvas.addEventListener('mousemove', e => {
    if (!isDrawingPath) return;
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    const gridX = Math.floor(mouseX / cellSize);
    const gridY = Math.floor(mouseY / cellSize);

    if (!isValidCell(gridX, gridY)) return;
    // Only add point if new and adjacent to last point
    const last = pathDrawingPoints[pathDrawingPoints.length - 1];
    if ((gridX === last.x && gridY === last.y) ||
        (Math.abs(gridX - last.x) > 1 || Math.abs(gridY - last.y) > 1)) return;

    pathDrawingPoints.push({ x: gridX, y: gridY });
    drawGame(true);
  });

  canvas.addEventListener('mouseup', e => {
    if (!isDrawingPath) return;
    isDrawingPath = false;

    // Finalize path only if it has at least 2 points
    if (pathDrawingPoints.length >= 2) {
      paths = pathDrawingPoints.slice();

      // Reset coins on path to start traveling from beginning
      coinsOnPath.length = 0;
      coinsOnPath.push({ offset: 0 });
      coinsOnPath.push({ offset: 2 });
      coinsOnPath.push({ offset: 4 });
    }
    pathDrawingPoints = [];
    drawGame();
  });

  // Add coins over time for fun (passive income from factories)
  setInterval(() => {
    let income = 0;
    factories.forEach(f => {
      income += f.type === 'central' ? 3 : 1;
    });
    coins += income;
    updateInfo();
  }, 1000);

  // Update coin display
  function updateInfo() {
    info.textContent = `Coins: ${coins}`;
  }

  // Draw entire game state
  let lastTimestamp = 0;
  function drawGame(drawTempPath = false) {
    drawGrid();
    drawFactories();
    if (paths.length >= 2) {
      drawPaths();
    }
    if (drawTempPath && pathDrawingPoints.length >= 2) {
      ctx.strokeStyle = '#ffea0055';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(pathDrawingPoints[0].x * cellSize + cellSize/2, pathDrawingPoints[0].y * cellSize + cellSize/2);
      for (let i = 1; i < pathDrawingPoints.length; i++) {
        ctx.lineTo(pathDrawingPoints[i].x * cellSize + cellSize/2, pathDrawingPoints[i].y * cellSize + cellSize/2);
      }
      ctx.stroke();
    }
  }

  // Main animation loop to update coins moving along path
  function animate(timestamp) {
    if (!lastTimestamp) lastTimestamp = timestamp;
    const deltaTime = (timestamp - lastTimestamp) / 1000; // seconds
    lastTimestamp = timestamp;

    drawGame();
    drawCoins(deltaTime);

    requestAnimationFrame(animate);
  }

  animate();

  // Notifications for feedback
  function showNotification(message) {
    const notif = document.createElement('div');
    notif.className = 'notification';
    notif.textContent = message;
    document.body.appendChild(notif);
    setTimeout(() => notif.remove(), 2600);
  }
</script>

</body>
</html>
