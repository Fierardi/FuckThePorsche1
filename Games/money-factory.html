<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Factory Grid Game</title>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      overflow: hidden;
      touch-action: none;
    }
    canvas {
      display: block;
      background: #f0f0f0;
    }
    .sidebar {
      position: absolute;
      left: 0;
      top: 0;
      width: 80px;
      height: 100%;
      background: #333;
      color: white;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding-top: 20px;
      z-index: 10;
    }
    .factory {
      width: 50px;
      height: 50px;
      background: yellow;
      margin-bottom: 20px;
      border: 2px solid white;
      border-radius: 5px;
    }
  </style>
</head>
<body>
  <div class="sidebar">
    <div class="factory" id="factory"></div>
  </div>
  <canvas id="gameCanvas"></canvas>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const factoryIcon = document.getElementById("factory");

    let width = window.innerWidth;
    let height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;

    const gridSize = 50;
    const factories = [];
    const paths = [];
    const coins = [];
    let currentPath = [];
    let drawing = false;
    let draggingFactory = false;
    let draggedFactory = null;

    // Helper functions
    const snapToGrid = (x, y) => ({
      x: Math.floor(x / gridSize) * gridSize,
      y: Math.floor(y / gridSize) * gridSize
    });

    const getTouchPos = (e) => {
      if (e.touches && e.touches.length > 0) {
        const rect = canvas.getBoundingClientRect();
        return {
          x: e.touches[0].clientX - rect.left,
          y: e.touches[0].clientY - rect.top
        };
      }
      return null;
    };

    const getMousePos = (e) => {
      const rect = canvas.getBoundingClientRect();
      return {
        x: e.clientX - rect.left,
        y: e.clientY - rect.top
      };
    };

    const spawnCoin = (factory) => {
      coins.push({
        x: factory.x + gridSize / 2,
        y: factory.y + gridSize / 2,
        vx: 0,
        vy: 0,
        pathIndex: 0
      });
    };

    // Draw everything
    function draw() {
      ctx.clearRect(0, 0, width, height);

      // Grid
      ctx.strokeStyle = "#ccc";
      for (let x = 0; x < width; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, height);
        ctx.stroke();
      }
      for (let y = 0; y < height; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();
      }

      // Paths
      ctx.strokeStyle = "blue";
      ctx.lineWidth = 4;
      paths.forEach((path) => {
        ctx.beginPath();
        for (let i = 0; i < path.length; i++) {
          const p = path[i];
          if (i === 0) ctx.moveTo(p.x, p.y);
          else ctx.lineTo(p.x, p.y);
        }
        ctx.stroke();
      });

      // Coins
      ctx.fillStyle = "gold";
      coins.forEach((coin) => {
        ctx.beginPath();
        ctx.arc(coin.x, coin.y, 8, 0, Math.PI * 2);
        ctx.fill();
      });

      // Factories
      factories.forEach((f) => {
        ctx.fillStyle = "yellow";
        ctx.fillRect(f.x, f.y, gridSize, gridSize);
        ctx.strokeStyle = "black";
        ctx.strokeRect(f.x, f.y, gridSize, gridSize);
      });

      // Current path (while drawing)
      if (drawing && currentPath.length > 1) {
        ctx.strokeStyle = "red";
        ctx.beginPath();
        currentPath.forEach((p, i) => {
          if (i === 0) ctx.moveTo(p.x, p.y);
          else ctx.lineTo(p.x, p.y);
        });
        ctx.stroke();
      }

      requestAnimationFrame(draw);
    }

    // Coin logic
    setInterval(() => {
      factories.forEach(spawnCoin);
    }, 1500); // Spawn every 1.5 seconds

    function updateCoins() {
      coins.forEach((coin) => {
        if (paths.length === 0) return;
        let nearestPath = null;
        let nearestDist = Infinity;

        paths.forEach((path) => {
          path.forEach((p) => {
            const dx = p.x - coin.x;
            const dy = p.y - coin.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < nearestDist && dist < 100) {
              nearestDist = dist;
              nearestPath = p;
            }
          });
        });

        if (nearestPath) {
          const dx = nearestPath.x - coin.x;
          const dy = nearestPath.y - coin.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist > 1) {
            coin.vx = (dx / dist) * 2;
            coin.vy = (dy / dist) * 2;
          }
        }

        coin.x += coin.vx;
        coin.y += coin.vy;
      });

      requestAnimationFrame(updateCoins);
    }

    // Input handlers
    function handleStart(x, y) {
      if (x < 80 && y < 80) {
        draggingFactory = true;
        draggedFactory = { x: x - 25, y: y - 25 };
        factories.push(draggedFactory);
      } else {
        drawing = true;
        currentPath = [];
        const start = snapToGrid(x, y);
        currentPath.push(start);
      }
    }

    function handleMove(x, y) {
      if (draggingFactory && draggedFactory) {
        draggedFactory.x = x - 25;
        draggedFactory.y = y - 25;
      } else if (drawing) {
        const point = snapToGrid(x, y);
        const lastPoint = currentPath[currentPath.length - 1];
        if (!lastPoint || point.x !== lastPoint.x || point.y !== lastPoint.y) {
          currentPath.push(point);
        }
      }
    }

    function handleEnd() {
      if (drawing && currentPath.length > 1) {
        paths.push(currentPath);
      }
      drawing = false;
      draggingFactory = false;
      draggedFactory = null;
    }

    // Mouse events
    canvas.addEventListener("mousedown", (e) => {
      const pos = getMousePos(e);
      handleStart(pos.x, pos.y);
    });

    canvas.addEventListener("mousemove", (e) => {
      const pos = getMousePos(e);
      handleMove(pos.x, pos.y);
    });

    canvas.addEventListener("mouseup", () => handleEnd());

    // Touch events
    canvas.addEventListener("touchstart", (e) => {
      const pos = getTouchPos(e);
      if (pos) handleStart(pos.x, pos.y);
    });

    canvas.addEventListener("touchmove", (e) => {
      const pos = getTouchPos(e);
      if (pos) handleMove(pos.x, pos.y);
    });

    canvas.addEventListener("touchend", () => handleEnd());

    draw();
    updateCoins();

    // Resize
    window.addEventListener("resize", () => {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
    });
  </script>
</body>
</html>
