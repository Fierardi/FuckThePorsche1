
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>MoneyFactory</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
  
  * {
    box-sizing: border-box;
  }
  
  body {
    margin: 0;
    background: linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 50%, #16213e 100%);
    font-family: 'Orbitron', monospace;
    color: white;
    display: flex;
    flex-direction: column;
    align-items: center;
    min-height: 100vh;
    overflow-x: hidden;
  }
  
  /* Animated background particles */
  .bg-particles {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: -1;
  }
  
  
  .particle {
    position: absolute;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 50%;
    animation: float 6s ease-in-out infinite;
  }
  
  @keyframes float {
    0%, 100% { transform: translateY(0px) rotate(0deg); opacity: 0.1; }
    50% { transform: translateY(-20px) rotate(180deg); opacity: 0.3; }
  }
  
  h1 {
    margin: 20px 0;
    font-size: 3rem;
    font-weight: 900;
    text-align: center;
    background:  #f7df5c;
    background-size: 300% 300%;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    animation: gradientShift 3s ease-in-out infinite;
    text-shadow: 0 0 30px rgba(255, 255, 255, 0.3);
  }
  
  @keyframes gradientShift {
    0%, 100% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
  }
  
  #gameArea {
    display: flex;
    flex-direction: row;
    align-items: flex-start;
    justify-content: center;
    gap: 40px;
    padding: 20px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 20px;
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
  }
  
  canvas {
    border: 2px solid rgba(0, 212, 255, 0.3);
    background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
    cursor: crosshair;
    border-radius: 15px;
    box-shadow: 0 10px 30px rgba(0, 212, 255, 0.2);
    transition: box-shadow 0.3s ease;
  }
  
  canvas:hover {
    box-shadow: 0 15px 40px rgba(0, 212, 255, 0.4);
  }
  
  #factoryIconWrapper {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
    gap: 15px;
  }
  
  .factory-section {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 15px;
    padding: 20px;
    border: 1px solid rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(5px);
    transition: all 0.3s ease;
  }
  
  .factory-section:hover {
    background: rgba(255, 255, 255, 0.08);
    transform: translateY(-2px);
  }
  
  .iconBox {
    width: 90px;
    height: 90px;
    font-size: 3.5rem;
    display: flex;
    align-items: center;
    justify-content: center;
    background: linear-gradient(135deg, #ff6b00, #ff8e53);
    color: white;
    border: 2px solid rgba(255, 255, 255, 0.2);
    border-radius: 15px;
    cursor: grab;
    user-select: none;
    margin-bottom: 10px;
    transition: all 0.3s ease;
    box-shadow: 0 5px 15px rgba(255, 107, 0, 0.3);
    position: relative;
    overflow: hidden;
  }
  
  .iconBox::before {
    content: '';
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.1), transparent);
    transform: rotate(45deg);
    transition: all 0.6s ease;
    opacity: 0;
  }
  
  .iconBox:hover::before {
    animation: shine 0.6s ease-in-out;
  }
  
  @keyframes shine {
    0% { transform: translateX(-100%) translateY(-100%) rotate(45deg); opacity: 0; }
    50% { opacity: 1; }
    100% { transform: translateX(100%) translateY(100%) rotate(45deg); opacity: 0; }
  }
  
  .iconBox:hover {
    transform: translateY(-3px) scale(1.05);
    box-shadow: 0 8px 25px rgba(255, 107, 0, 0.5);
  }
  
  .iconBox:active {
    cursor: grabbing;
    transform: scale(0.95);
  }
  
  .iconBox[data-type="central"] {
    background: linear-gradient(135deg, #e74c3c, #c0392b);
    box-shadow: 0 5px 15px rgba(231, 76, 60, 0.3);
  }
  
  .iconBox[data-type="central"]:hover {
    box-shadow: 0 8px 25px rgba(231, 76, 60, 0.5);
  }

  .iconBox[data-type="collection"] {
    background: linear-gradient(135deg, #00ff6a, #0d9747);
    box-shadow: 0 5px 15px #1d7040;
  }
  
  .iconBox[data-type="collection"]:hover {
    box-shadow: 0 8px 25px #1d7040;
  }

  .factoryCost {
    font-size: 1.1rem;
    color: #00d4ff;
    font-weight: 700;
    text-align: center;
    text-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
  }
  
  .factory-upgrade {
    font-size: 0.9rem;
    color: #f7df5c;
    text-align: center;
    margin-top: 5px;
    cursor: pointer;
    transition: all 0.3s ease;
  }
  
  .factory-upgrade:hover {
    color: #ffb347;
    text-shadow: 0 0 10px rgba(255, 179, 71, 0.5);
  }
  
  .factory-hidden{
    display: none;
  }

  .insufficient-funds {
    color: #ff4757 !important;
    animation: pulse 1s ease-in-out infinite;
  }
  
  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
  }
  
  #info {
    margin-top: 30px;
    margin-bottom: 30px;
    font-size: 2rem;
    font-weight: 700;
    text-align: center;
    background: rgba(255, 255, 255, 0.1);
    padding: 15px 30px;
    border-radius: 50px;
    border: 2px solid rgba(255, 255, 255, 0.2);
    backdrop-filter: blur(10px);
    color: #00d4ff;
    text-shadow: 0 0 20px rgba(0, 212, 255, 0.5);
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
    transition: all 0.3s ease;
  }
  
  #info:hover {
    transform: scale(1.05);
    box-shadow: 0 15px 40px rgba(0, 212, 255, 0.3);
  }
  
  .notification {
    position: fixed;
    top: 20px;
    right: 20px;
    background: rgba(255, 71, 87, 0.95);
    color: white;
    padding: 15px 25px;
    border-radius: 10px;
    font-weight: 700;
    z-index: 1000;
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.2);
    animation: slideIn 0.3s ease-out, fadeOut 0.3s ease-in 2.7s forwards;
  }
  
  @keyframes slideIn {
    from { transform: translateX(100%); opacity: 0; }
    to { transform: translateX(0); opacity: 1; }
  }
  
  @keyframes fadeOut {
    to { transform: translateX(100%); opacity: 0; }
  }
  
  .coin-earn-effect {
    position: fixed;
    font-size: 1.5rem;
    font-weight: 700;
    color: #ffdd00;
    pointer-events: none;
    z-index: 999;
    animation: coinEarn 1s ease-out forwards;
    text-shadow: 0 0 10px rgba(255, 221, 0, 0.8);
  }
  
  @keyframes coinEarn {
    0% { transform: translateY(0) scale(1); opacity: 1; }
    100% { transform: translateY(-50px) scale(1.5); opacity: 0; }
  }
  
  @media (max-width: 768px) {
    #gameArea {
      flex-direction: column;
      gap: 20px;
    }
    
    h1 {
      font-size: 2rem;
    }
    
    canvas {
      width: 400px;
      height: 400px;
    }
  }

  .factory-production {
    font-size: 0.8rem;
    color: #f7df5c;
    text-align: center;
    margin-top: 5px;
    text-shadow: 0 0 5px rgba(247, 223, 92, 0.5);
  }
  
</style>
<style>
.pause-overlay {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(20, 30, 40, 0.92);
  z-index: 9999;
  display: none;
  align-items: center;
  justify-content: center;
  transition: opacity 0.4s;
}
.pause-overlay.active {
  display: flex;
  opacity: 1;
  pointer-events: all;
}
.pause-content {
  background: #222e3a;
  padding: 36px 30px;
  border-radius: 16px;
  box-shadow: 0 6px 32px #0008;
  text-align: center;
}
.pause-content h2 {
  color: #00d4ff;
  margin-bottom: 28px;
  font-size: 2em;
  letter-spacing: 1px;
}
.pause-btn-main {
  font-size: 1.2em;
  padding: 12px 32px;
  background: linear-gradient(90deg, #00d4ff, #1de9b6);
  border: none;
  border-radius: 8px;
  color: #14202b;
  font-weight: bold;
  cursor: pointer;
  box-shadow: 0 2px 10px #00d4ff55;
  transition: background 0.2s, transform 0.2s;
}
.pause-btn-main:hover {
  background: linear-gradient(90deg, #1de9b6, #00d4ff);
  transform: scale(1.04);
}
.pause-btn {
  position: fixed;
  top: 18px;
  left: 28px;
  z-index: 10000;
  background: #182230cc;
  color: #00d4ff;
  border: none;
  border-radius: 50%;
  width: 48px;
  height: 48px;
  font-size: 1.9em;
  cursor: pointer;
  box-shadow: 0 2px 8px #00d4ff33;
  transition: background 0.2s, color 0.2s;
}
.pause-btn:hover {
  background: #00d4ff;
  color: #182230;
}


.menu-content {
  background: #222e3a;
  padding: 40px 32px;
  border-radius: 18px;
  box-shadow: 0 6px 32px #0008;
  text-align: center;
}
.menu-content h1 {
  color: #00d4ff;
  margin-bottom: 32px;
  font-size: 2.5em;
  letter-spacing: 2px;
}
.menu-btn {
  font-size: 1.3em;
  padding: 14px 36px;
  background: linear-gradient(90deg, #00d4ff, #1de9b6);
  border: none;
  border-radius: 8px;
  color: #14202b;
  font-weight: bold;
  cursor: pointer;
  box-shadow: 0 2px 10px #00d4ff55;
  transition: background 0.2s, transform 0.2s;
}
.menu-btn:hover {
  background: linear-gradient(90deg, #1de9b6, #00d4ff);
  transform: scale(1.04);
}
.menu-overlay.hide {
  opacity: 0;
  pointer-events: none;
}
</style>
</head>
<body>
  <!-- Pause Button -->
  <div class="pause-btn-container">
    <button id="pauseBtn" class="pause-btn" title="Pause Game">‚è∏</button>
  </div>
  <!-- Pause Menu Overlay -->
  <div id="pauseMenuOverlay" class="pause-overlay">
    <div class="pause-content">
      <h2>Game Paused</h2>
      <button id="mainMenuBtn" class="pause-btn-main">Main Menu</button>
      <button id="resumeBtn" class="pause-btn-main">Resume</button>
    </div>
  </div>


<div class="bg-particles" id="particles"></div>

<h1> MoneyFactory </h1>

<div id="info">üíé Points: 0</div>

<div id="gameArea">
  <canvas id="factory" width="500" height="500"></canvas>

  <div id="factoryIconWrapper">
    <div class="factory-section">
      <div id="collectionBox" class="iconBox" draggable="true" data-type="collection"></div>
      <div id="factoryCost" class="factoryCost">Cost: 0</div>
    </div>

    <div class="factory-section">
      <div id="normalFactory" class="iconBox" draggable="true" data-type="normal">üè≠</div>
      <div id="normalCost" class="factoryCost">Cost: 0</div>
      <div id="normalUpgrade" class="factory-upgrade">Upgrade (Lvl 1)</div>
      <div id="normalProduction" class="factory-production"></div>
    </div>

    <div class="factory-section">
      <div id="centralFactory" class="iconBox" draggable="true" data-type="central">‚ö°</div>
      <div id="centralCost" class="factoryCost">Cost: 120</div>
      <div id="centralUpgrade" class="factory-upgrade">Upgrade (Lvl 1)</div>
      <div id="centralProduction" class="factory-production"></div>
    </div>
  </div>
</div>

<script>
// Pause Menu logic
let paused = false;
const pauseBtn = document.getElementById('pauseBtn');
const pauseOverlay = document.getElementById('pauseMenuOverlay');
const resumeBtn = document.getElementById('resumeBtn');
const mainMenuBtn = document.getElementById('mainMenuBtn');

mainMenuBtn.addEventListener('click', () => {
  window.location.href = 'index.html';
});

function setPaused(state) {
  paused = state;
  if (paused) {
    pauseOverlay.classList.add('active');
  } else {
    pauseOverlay.classList.remove('active');
  }
}
pauseBtn.addEventListener('click', () => setPaused(true));
resumeBtn.addEventListener('click', () => setPaused(false));
// Optional: Pause/resume with Escape key
window.addEventListener('keydown', e => {
  if (e.key === 'Escape') setPaused(!paused);
});


function createParticles() {
  const particlesContainer = document.getElementById('particles');
  for (let i = 0; i < 50; i++) {
    const particle = document.createElement('div');
    particle.className = 'particle';
    particle.style.left = Math.random() * 100 + '%';
    particle.style.top = Math.random() * 100 + '%';
    particle.style.width = Math.random() * 4 + 2 + 'px';
    particle.style.height = particle.style.width;
    particle.style.animationDelay = Math.random() * 6 + 's';
    particle.style.animationDuration = (Math.random() * 4 + 4) + 's';
    particlesContainer.appendChild(particle);
  }
}

createParticles();

const canvas = document.getElementById('factory');
const ctx = canvas.getContext('2d');

const gridSize = 7;
const tileSize = 71;
// Canvas is fixed at 500x500px and tileSize is fixed at 71px as before.

const COMPONENTS = {
  EMPTY: 0,
  FACTORY_NORMAL: 1,
  FACTORY_CENTRAL: 2,
  COLLECTION: 3,
};

const grid = Array(gridSize).fill(null).map(() => Array(gridSize).fill(COMPONENTS.EMPTY));

let factories = [];
let factoryIdCounter = 0;
let playerPoints = 0;
let paths = {};
let coins = [];

// Factory upgrade levels and multipliers
let normalFactoryLevel = 1;
let centralFactoryLevel = 1;
let normalFactoryMultiplier = 1;
let centralFactoryMultiplier = 1;
let coinSpeedMultiplier = 1;

const info = document.getElementById('info');
const normalCostElem = document.getElementById('normalCost');
const centralCostElem = document.getElementById('centralCost');
const normalUpgradeElem = document.getElementById('normalUpgrade');
const centralUpgradeElem = document.getElementById('centralUpgrade');
const normalProductionElem = document.getElementById('normalProduction');
const centralProductionElem = document.getElementById('centralProduction');

const normalFactoryIcon = document.getElementById('normalFactory');
const centralFactoryIcon = document.getElementById('centralFactory');
const collectionIcon = document.getElementById('collectionBox');

const normalFactoryContainer = normalFactoryIcon.parentElement;
const centralFactoryContainer = centralFactoryIcon.parentElement;

let draggingFactoryType = null;
let isDrawing = false;
let currentFactoryId = null;
let currentPath = null;

// Factory management state
let selectedFactory = null;
let isMovingFactory = false;

// Game state
let collectionPlaced = false;
let normalFactoryPlaced = false;
let normalFactoriesCount = 0;
let centralFactoriesCount = 0;

// Touch interaction states
let touchStartTime = 0;
let isLongPress = false;
let longPressTimer = null;
let lastTouchTime = 0;

// Calculate costs
function getNormalFactoryCost() {
  return normalFactoriesCount === 0 ? 0 : 10 * (2 ** (normalFactoriesCount - 1));
}

function getCentralFactoryCost() {
  return 120 * (2 ** centralFactoriesCount);
}

// Calculate upgrade costs
function getNormalUpgradeCost() {
  return 50 * normalFactoryLevel;
}

function getCentralUpgradeCost() {
  return 200 * centralFactoryLevel;
}

function updateCostsDisplay() {
  const normalCost = getNormalFactoryCost();
  const centralCost = getCentralFactoryCost();
  
  normalCostElem.textContent = `Cost: ${normalCost}`;
  centralCostElem.textContent = `Cost: ${centralCost}`;
  
  // Update upgrade buttons
  normalUpgradeElem.textContent = `Upgrade (Lvl ${normalFactoryLevel}) - ${getNormalUpgradeCost()}`;
  centralUpgradeElem.textContent = `Upgrade (Lvl ${centralFactoryLevel}) - ${getCentralUpgradeCost()}`;
  
  // Add visual feedback for insufficient funds
  if (playerPoints < normalCost && normalCost > 0) {
    normalCostElem.classList.add('insufficient-funds');
  } else {
    normalCostElem.classList.remove('insufficient-funds');
  }
  
  if (playerPoints < centralCost) {
    centralCostElem.classList.add('insufficient-funds');
  } else {
    centralCostElem.classList.remove('insufficient-funds');
  }

  if (playerPoints < getNormalUpgradeCost()) {
    normalUpgradeElem.classList.add('insufficient-funds');
  } else {
    normalUpgradeElem.classList.remove('insufficient-funds');
  }

  if (playerPoints < getCentralUpgradeCost()) {
    centralUpgradeElem.classList.add('insufficient-funds');
  } else {
    centralUpgradeElem.classList.remove('insufficient-funds');
  }
}

const wipeThresholds = [1000, 100000, 1000000];
let factoriesWipedThresholds = [];

function updateInfo() {
  if (!collectionPlaced) {
    info.textContent = "üì¶ Place Collection Box First!";
    info.style.color = '#ff6b00';
  } else {
    // Format the points display
    let displayPoints;
    if (playerPoints >= 1000000000) {
      displayPoints = (playerPoints / 1000000000).toFixed(1) + 'b';
    } else if (playerPoints >= 1000000) {
      displayPoints = (playerPoints / 1000000).toFixed(1) + 'm';
    } else if (playerPoints >= 1000) {
      displayPoints = (playerPoints / 1000).toFixed(1) + 'k';
    } else {
      displayPoints = playerPoints.toString();
    }
    
    info.textContent = `üíé $: ${displayPoints}`;
    info.style.color = '#00d4ff';
  }

  // --- WIPE FACTORIES AT THRESHOLDS ---
  for (const threshold of wipeThresholds) {
    if (playerPoints >= threshold && !factoriesWipedThresholds.includes(threshold) && factories.length > 1) {
      factoriesWipedThresholds.push(threshold);
      // Choose the first factory to keep
      const keepFactory = factories[0];
      // Remove all other factories from grid and arrays
      for (let i = factories.length - 1; i >= 0; i--) {
        if (factories[i].id !== keepFactory.id) {
          // Remove from grid
          grid[factories[i].y][factories[i].x] = COMPONENTS.EMPTY;
          // Remove path
          delete paths[factories[i].id];
          // Remove coins
          coins = coins.filter(c => c.factoryId !== factories[i].id);
          factories.splice(i, 1);
        }
      }
      // Remove all paths except the one for the kept factory
      for (const pid in paths) {
        if (parseInt(pid) !== keepFactory.id) delete paths[pid];
      }
      // Remove all coins except for the kept factory
      coins = coins.filter(c => c.factoryId === keepFactory.id);
      showNotification(`All factories except one have vanished at ${threshold.toLocaleString()} points!`);
      updateProductionRates();
    }
  }
}

function showNotification(message) {
  const notification = document.createElement('div');
  notification.className = 'notification';
  notification.textContent = message;
  document.body.appendChild(notification);
  
  setTimeout(() => {
    if (notification.parentNode) {
      notification.parentNode.removeChild(notification);
    }
  }, 3000);
}

function showCoinEarnEffect(points, x, y) {
  const effect = document.createElement('div');
  effect.className = 'coin-earn-effect';
  effect.textContent = `+${points}`;
  effect.style.left = x + 'px';
  effect.style.top = y + 'px';
  document.body.appendChild(effect);
  
  setTimeout(() => {
    if (effect.parentNode) {
      effect.parentNode.removeChild(effect);
    }
  }, 1000);
}

// Upgrade functions
function upgradeNormalFactory() {
  const cost = getNormalUpgradeCost();
  if (playerPoints >= cost) {
    playerPoints -= cost;
    normalFactoryLevel++;
    normalFactoryMultiplier *= 1.3; // 30% increase
    coinSpeedMultiplier *= 1.1; // 10% speed increase
    updateCostsDisplay();
    updateInfo();
    updateProductionRates();
    showNotification(`Normal Factory upgraded to Level ${normalFactoryLevel}! (${Math.round(normalFactoryMultiplier * 100)}% output, ${Math.round(coinSpeedMultiplier * 100)}% speed)`);
  } else {
    showNotification(`Not enough points! You need ${cost} points to upgrade.`);
  }
}

function upgradeCentralFactory() {
  const cost = getCentralUpgradeCost();
  if (playerPoints >= cost) {
    playerPoints -= cost;
    centralFactoryLevel++;
    centralFactoryMultiplier *= 1.3; // 30% increase
    coinSpeedMultiplier *= 1.1; // 10% speed increase
    updateCostsDisplay();
    updateInfo();
    updateProductionRates();
    showNotification(`Central Factory upgraded to Level ${centralFactoryLevel}! (${Math.round(centralFactoryMultiplier * 100)}% output, ${Math.round(coinSpeedMultiplier * 100)}% speed)`);
  } else {
    showNotification(`Not enough points! You need ${cost} points to upgrade.`);
  }
}

function updateProductionRates() {
  // Calculate production per second for normal factories
  const normalProduction = normalFactoriesCount * normalFactoryMultiplier * (1 / coinSpeedMultiplier);
  normalProductionElem.textContent = `Produces: ${normalProduction.toFixed(1)}/s`;
  
  // Calculate production per second for central factories
  const centralProduction = centralFactoriesCount * centralFactoryMultiplier * (5 / coinSpeedMultiplier);
  centralProductionElem.textContent = `Produces: ${centralProduction.toFixed(1)}/s`;
}

// Add event listeners for upgrades
normalUpgradeElem.addEventListener('click', upgradeNormalFactory);
centralUpgradeElem.addEventListener('click', upgradeCentralFactory);

// Enhanced factory management functions
function showFactoryMenu(factory) {
  // Remove any existing menu
  const existingMenu = document.getElementById('factory-menu');
  if (existingMenu) existingMenu.remove();

  // Create menu optimized for touch
  const menu = document.createElement('div');
  menu.id = 'factory-menu';
  menu.style.position = 'fixed';
  menu.style.left = '20px';
  menu.style.top = '50%';
  menu.style.transform = 'translateY(-50%)';
  menu.style.background = 'rgba(0, 0, 0, 0.95)';
  menu.style.border = '2px solid #00d4ff';
  menu.style.borderRadius = '15px';
  menu.style.padding = '20px';
  menu.style.zIndex = '1000';
  menu.style.display = 'flex';
  menu.style.flexDirection = 'column';
  menu.style.gap = '15px';
  menu.style.minWidth = '200px';
  menu.style.boxShadow = '0 10px 30px rgba(0, 0, 0, 0.5)';

  // Add title
  const title = document.createElement('div');
  title.textContent = `${factory.type === 'normal' ? 'Normal' : 'Central'} Factory`;
  title.style.color = '#00d4ff';
  title.style.fontSize = '1.2rem';
  title.style.fontWeight = 'bold';
  title.style.textAlign = 'center';
  title.style.marginBottom = '10px';
  menu.appendChild(title);

  // Add buttons with larger touch areas
  const moveBtn = document.createElement('button');
  moveBtn.textContent = 'Move Factory';
  moveBtn.style.padding = '15px 25px';
  moveBtn.style.background = 'linear-gradient(135deg, #00d4ff, #0088ff)';
  moveBtn.style.border = 'none';
  moveBtn.style.borderRadius = '10px';
  moveBtn.style.color = 'white';
  moveBtn.style.cursor = 'pointer';
  moveBtn.style.fontSize = '1.1rem';
  moveBtn.style.fontWeight = 'bold';
  moveBtn.style.minHeight = '50px';
  moveBtn.style.transition = 'all 0.2s ease';
  moveBtn.addEventListener('touchstart', (e) => {
    e.preventDefault();
    moveBtn.style.transform = 'scale(0.95)';
  });
  moveBtn.addEventListener('touchend', (e) => {
    e.preventDefault();
    moveBtn.style.transform = 'scale(1)';
    isMovingFactory = true;
    menu.remove();
    showNotification('Tap new location for factory');
  });
  moveBtn.addEventListener('click', (e) => {
    e.preventDefault();
    isMovingFactory = true;
    menu.remove();
    showNotification('Tap new location for factory');
  });

  const removeBtn = document.createElement('button');
  removeBtn.textContent = 'Remove Factory';
  removeBtn.style.padding = '15px 25px';
  removeBtn.style.background = 'linear-gradient(135deg, #ff4757, #cc0000)';
  removeBtn.style.border = 'none';
  removeBtn.style.borderRadius = '10px';
  removeBtn.style.color = 'white';
  removeBtn.style.cursor = 'pointer';
  removeBtn.style.fontSize = '1.1rem';
  removeBtn.style.fontWeight = 'bold';
  removeBtn.style.minHeight = '50px';
  removeBtn.style.transition = 'all 0.2s ease';
  removeBtn.addEventListener('touchstart', (e) => {
    e.preventDefault();
    removeBtn.style.transform = 'scale(0.95)';
  });
  removeBtn.addEventListener('touchend', (e) => {
    e.preventDefault();
    removeBtn.style.transform = 'scale(1)';
    removeFactory(factory.x, factory.y);
    menu.remove();
  });
  removeBtn.addEventListener('click', (e) => {
    e.preventDefault();
    removeFactory(factory.x, factory.y);
    menu.remove();
  });

  const cancelBtn = document.createElement('button');
  cancelBtn.textContent = 'Cancel';
  cancelBtn.style.padding = '15px 25px';
  cancelBtn.style.background = 'linear-gradient(135deg, #666666, #333333)';
  cancelBtn.style.border = 'none';
  cancelBtn.style.borderRadius = '10px';
  cancelBtn.style.color = 'white';
  cancelBtn.style.cursor = 'pointer';
  cancelBtn.style.fontSize = '1.1rem';
  cancelBtn.style.fontWeight = 'bold';
  cancelBtn.style.minHeight = '50px';
  cancelBtn.style.transition = 'all 0.2s ease';
  cancelBtn.addEventListener('touchstart', (e) => {
    e.preventDefault();
    cancelBtn.style.transform = 'scale(0.95)';
  });
  cancelBtn.addEventListener('touchend', (e) => {
    e.preventDefault();
    cancelBtn.style.transform = 'scale(1)';
    menu.remove();
    selectedFactory = null;
  });
  cancelBtn.addEventListener('click', (e) => {
    e.preventDefault();
    menu.remove();
    selectedFactory = null;
  });

  // --- Delete Path Button ---
  const deletePathBtn = document.createElement('button');
  deletePathBtn.textContent = 'Delete Path';
  deletePathBtn.className = 'menu-btn';
  deletePathBtn.style.background = 'linear-gradient(90deg, #ff4757, #ff6b00)';
  deletePathBtn.style.color = '#fff';
  deletePathBtn.style.marginBottom = '14px';
  deletePathBtn.addEventListener('click', (e) => {
    e.preventDefault();
    delete paths[factory.id];
    // Remove all coins from this factory
    coins = coins.filter(c => c.factoryId !== factory.id);
    showNotification('Path deleted for this factory!');
    updateProductionRates();
    menu.remove();
    selectedFactory = null;
  });

  menu.appendChild(moveBtn);
  menu.appendChild(removeBtn);
  menu.appendChild(deletePathBtn);
  menu.appendChild(cancelBtn);

  document.body.appendChild(menu);
}

function removeFactory(gridX, gridY) {
  const tileType = grid[gridY][gridX];
  if (tileType === COMPONENTS.FACTORY_NORMAL || tileType === COMPONENTS.FACTORY_CENTRAL) {
    // Find and remove the factory
    const factoryIndex = factories.findIndex(f => f.x === gridX && f.y === gridY);
    if (factoryIndex !== -1) {
      const factory = factories[factoryIndex];
      
      // Remove any coins from this factory
      coins = coins.filter(c => c.factoryId !== factory.id);
      
      // Remove the path
      delete paths[factory.id];
      
      // Remove the factory
      factories.splice(factoryIndex, 1);
      
      // Update counts
      if (factory.type === 'normal') {
        normalFactoriesCount--;
      } else {
        centralFactoriesCount--;
      }
      
      // Reset the grid position
      grid[gridY][gridX] = COMPONENTS.EMPTY;
      
      // Refund some points
      const refund = factory.type === 'normal' ? 
        Math.floor(getNormalFactoryCost() * 0.5) : 
        Math.floor(getCentralFactoryCost() * 0.5);
      playerPoints += refund;
      
      showNotification(`Factory removed! Refunded ${refund} points`);
      updateInfo();
      updateCostsDisplay();
      updateProductionRates();
    }
  }
  selectedFactory = null;
}

function moveFactory(fromX, fromY, toX, toY) {
  if (grid[toY][toX] !== COMPONENTS.EMPTY) {
    showNotification("Cannot move factory to occupied tile!");
    return false;
  }
  
  const factoryIndex = factories.findIndex(f => f.x === fromX && f.y === fromY);
  if (factoryIndex === -1) return false;
  
  const factory = factories[factoryIndex];
  
  // Move the factory
  grid[fromY][fromX] = COMPONENTS.EMPTY;
  grid[toY][toX] = factory.type === 'normal' ? COMPONENTS.FACTORY_NORMAL : COMPONENTS.FACTORY_CENTRAL;
  factory.x = toX;
  factory.y = toY;

  // Remove the path for this factory when moved
  if (paths[factory.id]) {
    delete paths[factory.id];
  }

  // Try to auto-connect to an adjacent path if present (same as on placement)
  const adjacentOffsets = [
    {dx: 0, dy: -1}, // up
    {dx: 0, dy: 1},  // down
    {dx: -1, dy: 0}, // left
    {dx: 1, dy: 0},  // right
  ];
  let connected = false;
  for (const offset of adjacentOffsets) {
    const nx = toX + offset.dx;
    const ny = toY + offset.dy;
    if (
      nx >= 0 && nx < gridSize &&
      ny >= 0 && ny < gridSize
    ) {
      for (const pathId in paths) {
        const path = paths[pathId];
        if (Array.isArray(path)) {
          for (let i = 0; i < path.length; i++) {
            if (path[i].x === nx && path[i].y === ny) {
              // Connect the new factory's path to this path
              paths[factory.id] = [{x: toX, y: toY}, ...path.slice(i)];
              connected = true;
              break;
            }
          }
        }
        if (connected) break;
      }
    }
    if (connected) break;
  }
  if (!connected) {
    paths[factory.id] = [];
  }

  showNotification("Factory moved successfully! Path updated.");
  updateProductionRates();
  return true;
}

// Enhanced touch event handlers for factory icons
function handleTouchStart(e, factoryType) {
  e.preventDefault();
  draggingFactoryType = factoryType;
  
  // Visual feedback
  e.target.style.transform = 'scale(1.1)';
  e.target.style.opacity = '0.8';
}

function handleTouchEnd(e) {
  e.preventDefault();
  
  // Reset visual state
  if (e.target) {
    e.target.style.transform = '';
    e.target.style.opacity = '';
  }
  
  // Check if dropped over canvas
  const canvasRect = canvas.getBoundingClientRect();
  const touch = e.changedTouches[0];
  
  if (touch.clientX >= canvasRect.left && touch.clientX <= canvasRect.right &&
      touch.clientY >= canvasRect.top && touch.clientY <= canvasRect.bottom) {
    
    const mouseX = touch.clientX - canvasRect.left;
    const mouseY = touch.clientY - canvasRect.top;
    const gridX = Math.floor(mouseX / tileSize);
    const gridY = Math.floor(mouseY / tileSize);

    if (gridX >= 0 && gridX < gridSize && gridY >= 0 && gridY < gridSize) {
      // Handle collection box placement
      if (draggingFactoryType === 'collection') {
        if (!collectionPlaced) {
          grid[gridY][gridX] = COMPONENTS.COLLECTION;
          collectionPlaced = true;
          hideCollectionIcon();
          updateInfo();
          showNotification("Collection box placed! Now you can build factories.");
        } else {
          showNotification("Collection box already placed!");
        }
        return;
      }
      
      // Prevent factory placement if collection box not placed
      if (!collectionPlaced) {
        showNotification("Place the collection box first!");
        return;
      }
      
      let cost = 0;
      if (draggingFactoryType === 'normal') {
        cost = getNormalFactoryCost();
        if (!normalFactoryPlaced){
          normalFactoryPlaced = true;
          showCentralFactory();
        }
      } else if (draggingFactoryType === 'central') {
        cost = getCentralFactoryCost();
      }

      // Check if player can buy
      if (playerPoints >= cost || (draggingFactoryType === 'normal' && normalFactoriesCount === 0)) {
        let compType;
        if (draggingFactoryType === 'normal') {
          compType = COMPONENTS.FACTORY_NORMAL;
          normalFactoriesCount++;
          if (cost > 0) playerPoints -= cost;
        } else {
          compType = COMPONENTS.FACTORY_CENTRAL;
          centralFactoriesCount++;
          playerPoints -= cost;
        }
        grid[gridY][gridX] = compType;
        const id = factoryIdCounter++;
        factories.push({ id, x: gridX, y: gridY, type: draggingFactoryType });
        // Try to auto-connect to an adjacent path if present (touch version)
        const adjacentOffsets = [
          {dx: 0, dy: -1}, // up
          {dx: 0, dy: 1},  // down
          {dx: -1, dy: 0}, // left
          {dx: 1, dy: 0},  // right
        ];
        let connected = false;
        for (const offset of adjacentOffsets) {
          const nx = gridX + offset.dx;
          const ny = gridY + offset.dy;
          if (
            nx >= 0 && nx < gridSize &&
            ny >= 0 && ny < gridSize
          ) {
            // Check if this tile is part of any path
            for (const pathId in paths) {
              const path = paths[pathId];
              if (Array.isArray(path)) {
                for (let i = 0; i < path.length; i++) {
                  if (path[i].x === nx && path[i].y === ny) {
                    // Connect the new factory's path to this path
                    paths[id] = [{x: gridX, y: gridY}, ...path.slice(i)];
                    connected = true;
                    break;
                  }
                }
              }
              if (connected) break;
            }
          }
          if (connected) break;
        }
        if (!connected) {
          paths[id] = [];
        }
        updateInfo();
        updateCostsDisplay();
        updateProductionRates();
      } else {
        showNotification(`Not enough points! You need ${cost} points to buy a ${draggingFactoryType} factory.`);
      }
    }
  }
  
  draggingFactoryType = null;
}

// Enhanced touch event handlers for factory icons
normalFactoryIcon.addEventListener('touchstart', (e) => handleTouchStart(e, 'normal'), { passive: false });
normalFactoryIcon.addEventListener('touchend', handleTouchEnd, { passive: false });

centralFactoryIcon.addEventListener('touchstart', (e) => handleTouchStart(e, 'central'), { passive: false });
centralFactoryIcon.addEventListener('touchend', handleTouchEnd, { passive: false });

collectionIcon.addEventListener('touchstart', (e) => handleTouchStart(e, 'collection'), { passive: false });
collectionIcon.addEventListener('touchend', handleTouchEnd, { passive: false });

// Keep existing drag and drop for desktop
normalFactoryIcon.addEventListener('dragstart', (e) => {
  draggingFactoryType = 'normal';
});
normalFactoryIcon.addEventListener('dragend', (e) => {
  draggingFactoryType = null;
});

centralFactoryIcon.addEventListener('dragstart', (e) => {
  draggingFactoryType = 'central';
});
centralFactoryIcon.addEventListener('dragend', (e) => {
  draggingFactoryType = null;
});

collectionIcon.addEventListener('dragstart', (e) => {
  draggingFactoryType = 'collection';
});
collectionIcon.addEventListener('dragend', (e) => {
  draggingFactoryType = null;
});

canvas.addEventListener('dragover', (e) => {
  e.preventDefault();
});

canvas.addEventListener('drop', (e) => {
  if (!draggingFactoryType) return;

  const rect = canvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;
  const gridX = Math.floor(mouseX / tileSize);
  const gridY = Math.floor(mouseY / tileSize);

  if (gridX < 0 || gridX >= gridSize || gridY < 0 || gridY >= gridSize) return;
  if (grid[gridY][gridX] !== COMPONENTS.EMPTY) return;

  // Handle collection box placement
  if (draggingFactoryType === 'collection') {
    if (!collectionPlaced) {
      grid[gridY][gridX] = COMPONENTS.COLLECTION;
      collectionPlaced = true;
      hideCollectionIcon();
      updateInfo();
      showNotification("Collection box placed! Now you can build factories.");
    } else {
      showNotification("Collection box already placed!");
    }
    return;
  }
  
  // Prevent factory placement if collection box not placed
  if (!collectionPlaced) {
    showNotification("Place the collection box first!");
    return;
  }

  let cost = 0;
  if (draggingFactoryType === 'normal') {
    cost = getNormalFactoryCost();
    if (!normalFactoryPlaced){
      normalFactoryPlaced = true;
      showCentralFactory();
    }
  } else if (draggingFactoryType === 'central') {
    cost = getCentralFactoryCost();
  }

  // Check if player can buy
  if (playerPoints >= cost || (draggingFactoryType === 'normal' && normalFactoriesCount === 0)) {
    let compType;
    if (draggingFactoryType === 'normal') {
      compType = COMPONENTS.FACTORY_NORMAL;
      normalFactoriesCount++;
      if (cost > 0) playerPoints -= cost;
    } else {
      compType = COMPONENTS.FACTORY_CENTRAL;
      centralFactoriesCount++;
      playerPoints -= cost;
    }
    grid[gridY][gridX] = compType;
    const id = factoryIdCounter++;
    factories.push({ id, x: gridX, y: gridY, type: draggingFactoryType });
    // Try to auto-connect to an adjacent path if present
    const adjacentOffsets = [
      {dx: 0, dy: -1}, // up
      {dx: 0, dy: 1},  // down
      {dx: -1, dy: 0}, // left
      {dx: 1, dy: 0},  // right
    ];
    let connected = false;
    for (const offset of adjacentOffsets) {
      const nx = gridX + offset.dx;
      const ny = gridY + offset.dy;
      if (
        nx >= 0 && nx < gridSize &&
        ny >= 0 && ny < gridSize
      ) {
        // Check if this tile is part of any path
        for (const pathId in paths) {
          const path = paths[pathId];
          if (Array.isArray(path)) {
            for (let i = 0; i < path.length; i++) {
              if (path[i].x === nx && path[i].y === ny) {
                // Connect the new factory's path to this path
                paths[id] = [{x: gridX, y: gridY}, ...path.slice(i)];
                connected = true;
                break;
              }
            }
          }
          if (connected) break;
        }
      }
      if (connected) break;
    }
    if (!connected) {
      paths[id] = [];
    }
    updateInfo();
    updateCostsDisplay();
    updateProductionRates();
  } else {
    showNotification(`Not enough points! You need ${cost} points to buy a ${draggingFactoryType} factory.`);
  }
});

// Enhanced touch support for canvas interactions
function getEventPos(e) {
  const rect = canvas.getBoundingClientRect();
  if (e.type === 'touchend' && e.changedTouches && e.changedTouches.length > 0) {
    return {
      x: e.changedTouches[0].clientX - rect.left,
      y: e.changedTouches[0].clientY - rect.top
    };
  } else if (e.touches && e.touches.length > 0) {
    return {
      x: e.touches[0].clientX - rect.left,
      y: e.touches[0].clientY - rect.top
    };
  } else {
    return {
      x: e.clientX - rect.left,
      y: e.clientY - rect.top
    };
  }
}


function clearLongPressTimer() {
  if (longPressTimer) {
    clearTimeout(longPressTimer);
    longPressTimer = null;
  }
}

function handleCanvasTouchStart(e) {
  e.preventDefault();
  const pos = getEventPos(e);
  const gridX = Math.floor(pos.x / tileSize);
  const gridY = Math.floor(pos.y / tileSize);

  if (gridX < 0 || gridX >= gridSize || gridY < 0 || gridY >= gridSize) return;

  touchStartTime = Date.now();
  touchStartPos = { x: pos.x, y: pos.y };
  isLongPress = false;

  // Start long press timer for factory menu
  const factory = factories.find(f => f.x === gridX && f.y === gridY);
  if (factory && !isMovingFactory) {
    longPressTimer = setTimeout(() => {
      isLongPress = true;
      selectedFactory = factory;
      showFactoryMenu(factory);
      // Add haptic feedback if available
      if (navigator.vibrate) {
        navigator.vibrate(50);
      }
    }, 500); // 500ms for long press
  }

  // If not long pressing, start drawing
  if (!isLongPress && !factory) {
    startDrawing(e);
  }
}

function handleCanvasTouchMove(e) {
  e.preventDefault();
  const pos = getEventPos(e);
  
  // Check if we've moved too far for a long press
  const distance = Math.sqrt(
    Math.pow(pos.x - touchStartPos.x, 2) + 
    Math.pow(pos.y - touchStartPos.y, 2)
  );
  
  if (distance > 10) {
    clearLongPressTimer();
    isLongPress = false;
  }

  // Continue drawing if we're in drawing mode
  if (isDrawing) {
    continueDrawing(e);
  }
}

function handleCanvasTouchEnd(e) {
  e.preventDefault();
  clearLongPressTimer();
  
  const pos = getEventPos(e);
  const gridX = Math.floor(pos.x / tileSize);
  const gridY = Math.floor(pos.y / tileSize);

  console.log('[handleCanvasTouchEnd] gridX:', gridX, 'gridY:', gridY, 'isMovingFactory:', isMovingFactory, 'selectedFactory:', selectedFactory);

  if (gridX < 0 || gridX >= gridSize || gridY < 0 || gridY >= gridSize) return;

  const currentTime = Date.now();
  const touchDuration = currentTime - touchStartTime;

  // Handle factory moving
  if (isMovingFactory && selectedFactory) {
    console.log('[handleCanvasTouchEnd] Attempting to move factory:', selectedFactory, 'to', gridX, gridY);
    if (grid[gridY][gridX] === COMPONENTS.EMPTY) {
      if (moveFactory(selectedFactory.x, selectedFactory.y, gridX, gridY)) {
        isMovingFactory = false;
        selectedFactory = null;
        console.log('[handleCanvasTouchEnd] Move successful, clearing move mode');
      }
    } else {
      showNotification("Cannot move factory to occupied tile! Tap another empty tile or Cancel.");
      console.log('[handleCanvasTouchEnd] Invalid move, tile occupied');
      // Do NOT clear isMovingFactory or selectedFactory, let user try again
      return;
    }
    return;
  }

  // Handle short tap on factory (if not long press)
  if (!isLongPress && touchDuration < 500) {
    const factory = factories.find(f => f.x === gridX && f.y === gridY);
    if (factory) {
      // Double tap detection
      if (currentTime - lastTouchTime < 300) {
        // Double tap - show menu immediately
        selectedFactory = factory;
        showFactoryMenu(factory);
        console.log('[handleCanvasTouchEnd] Double tap, showing menu for', factory);
      }
      lastTouchTime = currentTime;
    }
  }

  // Stop drawing
  if (isDrawing) {
    stopDrawing(e);
  }
}

function handleFactoryClick(e) {
  e.preventDefault();
  const pos = getEventPos(e);
  const gridX = Math.floor(pos.x / tileSize);
  const gridY = Math.floor(pos.y / tileSize);

  if (gridX < 0 || gridX >= gridSize || gridY < 0 || gridY >= gridSize) return;

  // Check if we're in moving mode
  if (isMovingFactory && selectedFactory) {
    if (grid[gridY][gridX] === COMPONENTS.EMPTY) {
      if (moveFactory(selectedFactory.x, selectedFactory.y, gridX, gridY)) {
        isMovingFactory = false;
        selectedFactory = null;
      }
    } else {
      showNotification("Cannot move factory to occupied tile! Tap another empty tile or Cancel.");
      // Do NOT clear isMovingFactory or selectedFactory, let user try again
      return;
    }
    return;
  }

  // Only show menu if clicked directly on a factory
  // Check if clicked on a factory
  const factory = factories.find(f => f.x === gridX && f.y === gridY);
  if (factory) {
    selectedFactory = factory;
    showFactoryMenu(factory);
  }
}

function startDrawing(e) {
  e.preventDefault();
  const pos = getEventPos(e);
  const gridX = Math.floor(pos.x / tileSize);
  const gridY = Math.floor(pos.y / tileSize);

  if (gridX < 0 || gridX >= gridSize || gridY < 0 || gridY >= gridSize) return;

  // Prevent path drawing if collection box not placed
  if (!collectionPlaced) {
    showNotification("Place the collection box first!");
    return;
  }

  const factory = factories.find(f => f.x === gridX && f.y === gridY);
  if (factory && !selectedFactory) {
    // Start drawing from the factory tile, but do NOT add the factory tile to the path yet
    isDrawing = true;
    currentFactoryId = factory.id;
    currentPath = [];
    paths[currentFactoryId] = currentPath;
    // Wait for first move to add the adjacent tile
  } else if (!factory) {
    // Check if the tile is adjacent to a factory
    let adjacentFactory = null;
    for (const f of factories) {
      if (
        (Math.abs(f.x - gridX) === 1 && f.y === gridY) ||
        (Math.abs(f.y - gridY) === 1 && f.x === gridX)
      ) {
        adjacentFactory = f;
        break;
      }
    }
    if (adjacentFactory && !selectedFactory) {
      // Start drawing from the adjacent tile only (do NOT add the factory tile)
      isDrawing = true;
      currentFactoryId = adjacentFactory.id;
      // Try to auto-connect to an adjacent path if present (path start version)
      const adjacentOffsets = [
        {dx: 0, dy: -1}, // up
        {dx: 0, dy: 1},  // down
        {dx: -1, dy: 0}, // left
        {dx: 1, dy: 0},  // right
      ];
      let connected = false;
      for (const offset of adjacentOffsets) {
        const nx = gridX + offset.dx;
        const ny = gridY + offset.dy;
        if (
          nx >= 0 && nx < gridSize &&
          ny >= 0 && ny < gridSize
        ) {
          for (const pathId in paths) {
            const path = paths[pathId];
            if (Array.isArray(path)) {
              for (let i = 0; i < path.length; i++) {
                if (path[i].x === nx && path[i].y === ny) {
                  // Connect the new path to this path
                  // Check that the rest of the path does not go through any other factory (except the starting factory)
                  let valid = true;
                  for (let j = i; j < path.length; j++) {
                    const tile = path[j];
                    // Allow the starting factory but not any other
                    if ((tile.x !== adjacentFactory.x || tile.y !== adjacentFactory.y) &&
                        (grid[tile.y][tile.x] === COMPONENTS.FACTORY_NORMAL || grid[tile.y][tile.x] === COMPONENTS.FACTORY_CENTRAL)) {
                      valid = false;
                      break;
                    }
                  }
                  if (valid) {
                    // Only connect up to the first factory (if any)
                    let cutoff = path.length;
                    for (let j = i + 1; j < path.length; j++) {
                      const tile = path[j];
                      if (grid[tile.y][tile.x] === COMPONENTS.FACTORY_NORMAL || grid[tile.y][tile.x] === COMPONENTS.FACTORY_CENTRAL) {
                        cutoff = j;
                        break;
                      }
                    }
                    currentPath = [{x: adjacentFactory.x, y: adjacentFactory.y}, {x: gridX, y: gridY}, ...path.slice(i, cutoff)];
                    paths[currentFactoryId] = currentPath;
                    connected = true;
                  }
                  break;
                }
              }
            }
            if (connected) break;
          }
        }
        if (connected) break;
      }
      if (!connected) {
        currentPath = [{x: adjacentFactory.x, y: adjacentFactory.y}, {x: gridX, y: gridY}];
        paths[currentFactoryId] = currentPath;
      }
    } else {
      // Allow path drawing even if menu is open
      isDrawing = true;
    }
  }
}

function continueDrawing(e) {
  if (!isDrawing) return;
  e.preventDefault();
  touchDidDraw = true;

  const pos = getEventPos(e);
  const gridX = Math.floor(pos.x / tileSize);
  const gridY = Math.floor(pos.y / tileSize);

  if (gridX < 0 || gridX >= gridSize || gridY < 0 || gridY >= gridSize) return;

  // Check if the current tile is blocked by a factory (but allow collection boxes)
  const currentTile = grid[gridY][gridX];
  if (currentTile === COMPONENTS.FACTORY_NORMAL || currentTile === COMPONENTS.FACTORY_CENTRAL) {
    return; // Cannot draw path through factories
  }

  // Only allow adjacent tiles (no skipping blocks)
  if (currentPath && currentPath.length > 0) {
    const last = currentPath[currentPath.length - 1];
    const dx = Math.abs(last.x - gridX);
    const dy = Math.abs(last.y - gridY);
    
    // Only allow orthogonal movement (no diagonals)
    if ((dx === 1 && dy === 0) || (dx === 0 && dy === 1)) {
      if (!currentPath.find(p => p.x === gridX && p.y === gridY)) {
        currentPath.push({ x: gridX, y: gridY });
      }
    }
  } else if (currentFactoryId) {
    // First move from the factory: start the path with the first adjacent tile only
    currentPath = paths[currentFactoryId] || [];
    currentPath.push({ x: gridX, y: gridY });
  }
}


function stopDrawing(e) {
  if (!isDrawing) return;
  e.preventDefault();
  isDrawing = false;

  if (!currentFactoryId || !currentPath) return;

  // Validate the entire path - remove any segments that go through factories
  const validatedPath = [];
  for (let i = 0; i < currentPath.length; i++) {
    const tile = currentPath[i];
    const tileType = grid[tile.y][tile.x];
    
    // Allow the starting factory, collection boxes, and empty tiles
    if (i === 0 || 
        tileType === COMPONENTS.EMPTY || 
        tileType === COMPONENTS.COLLECTION) {
      validatedPath.push(tile);
    }
    // If we hit a factory (other than the starting one), stop the path here
    else if (tileType === COMPONENTS.FACTORY_NORMAL || tileType === COMPONENTS.FACTORY_CENTRAL) {
      break;
    }
  }

  // Update the path with the validated version
  currentPath = validatedPath;
  paths[currentFactoryId] = currentPath;

  // Check for path merging with the validated path
  for (const f of factories) {
    if (f.id === currentFactoryId) continue;
    const otherPath = paths[f.id];
    if (!otherPath || otherPath.length === 0) continue;

    let intersectIndexCurrent = -1;
    let intersectIndexOther = -1;

    for (let i = 0; i < currentPath.length; i++) {
      const tile = currentPath[i];
      const otherIdx = otherPath.findIndex(t => t.x === tile.x && t.y === tile.y);
      if (otherIdx !== -1) {
        intersectIndexCurrent = i;
        intersectIndexOther = otherIdx;
        break;
      }
    }

    if (intersectIndexCurrent !== -1 && intersectIndexOther !== -1) {
      const mergedPath = currentPath.slice(0, intersectIndexCurrent)
        .concat(otherPath.slice(intersectIndexOther));

      paths[currentFactoryId] = mergedPath;
      currentPath = mergedPath;
      break;
    }
  }

  currentFactoryId = null;
  currentPath = null;
}

// Add both mouse and touch event listeners for factory interaction
canvas.addEventListener('click', handleFactoryClick);


// Add both mouse and touch event listeners for path drawing
canvas.addEventListener('mousedown', startDrawing);
canvas.addEventListener('mousemove', continueDrawing);
canvas.addEventListener('mouseup', stopDrawing);

// Touch event state for unified handling
let touchStartPos = null;
let touchDidDraw = false;
canvas.addEventListener('touchstart', function(e) {
  touchDidDraw = false;
  const pos = getEventPos(e);
  touchStartPos = pos;
  // Only start drawing if not on a factory tile
  const gridX = Math.floor(pos.x / tileSize);
  const gridY = Math.floor(pos.y / tileSize);
  const factory = factories.find(f => f.x === gridX && f.y === gridY);
  if (!factory) {
    startDrawing(e);
  }
}, { passive: false });
canvas.addEventListener('touchmove', function(e) {
  if (!touchStartPos) return;
  const pos = getEventPos(e);
  const dx = Math.abs(pos.x - touchStartPos.x);
  const dy = Math.abs(pos.y - touchStartPos.y);
  if (dx > 5 || dy > 5) touchDidDraw = true;
  continueDrawing(e);
}, { passive: false });
canvas.addEventListener('touchend', function(e) {
  const pos = getEventPos(e);
  const gridX = Math.floor(pos.x / tileSize);
  const gridY = Math.floor(pos.y / tileSize);
  const factory = factories.find(f => f.x === gridX && f.y === gridY);
  // Allow move mode to work
  if (isMovingFactory && selectedFactory) {
    handleCanvasTouchEnd(e);
    touchDidDraw = false;
    touchStartPos = null;
    return;
  }
  if (touchDidDraw) {
    if (!factory) {
      stopDrawing(e);
    }
    // If touchDidDraw and ended on a factory, do nothing (prevents path removal)
  } else {
    // If tap on factory, open menu
    handleFactoryClick(e);
    handleCanvasTouchEnd(e);
  }
  touchDidDraw = false;
  touchStartPos = null;
}, { passive: false });

class Coin {
  constructor(factoryId) {
    this.factoryId = factoryId;
    this.pathIndex = 0;
    this.offset = 0;
    this.speed = 1;
    this.active = true;
    this.pulsePhase = Math.random() * Math.PI * 2; // For pulsing animation
  }

  move() {
    const path = paths[this.factoryId];
    if (!path || path.length < 2) return;

    if (this.pathIndex >= path.length - 1) {
      const last = path[path.length - 1];
      if (grid[last.y][last.x] === COMPONENTS.COLLECTION) {
        this.active = false;
        // Award points with multiplier applied
        const factory = factories.find(f => f.id === this.factoryId);
        let points = 1;
        if (factory.type === 'central') {
          points = 5 * centralFactoryMultiplier;
        } else {
          points = 1 * normalFactoryMultiplier;
        }
        points = Math.round(points);
        playerPoints += points;
        
        // Show coin earn effect
        const rect = canvas.getBoundingClientRect();
        showCoinEarnEffect(points, rect.left + last.x * tileSize + tileSize/2, rect.top + last.y * tileSize);
        
        updateInfo();
        updateCostsDisplay();
      }
      return;
    }

    const current = path[this.pathIndex];
    const next = path[this.pathIndex + 1];

    this.offset += this.speed;
    if (this.offset >= tileSize) {
      this.offset = 0;
      this.pathIndex++;
    }
    
    this.pulsePhase += 0.2; // Update pulse animation
  }

  getDrawPosition() {
    const path = paths[this.factoryId];
    if (!path || path.length < 2) return null;
    if (this.pathIndex >= path.length - 1) return null;

    const current = path[this.pathIndex];
    const next = path[this.pathIndex + 1];

    const px = current.x * tileSize + (next.x - current.x) * this.offset;
    const py = current.y * tileSize + (next.y - current.y) * this.offset;
    return { x: px, y: py };
  }
}

function drawGrid() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Draw tiles with enhanced graphics
  for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
      const tileX = x * tileSize;
      const tileY = y * tileSize;

      // Highlight path tiles with Convai bolt color
      let isPathTile = false;
      for (const pId in paths) {
        const path = paths[pId];
        if (path && path.find(tile => tile.x === x && tile.y === y)) {
          isPathTile = true;
          break;
        }
      }
      if (isPathTile) {
        // Bolt blue fill with glow
        ctx.save();
        ctx.shadowColor = '#00d4ff';
        ctx.shadowBlur = 16;
        ctx.fillStyle = 'rgba(0, 212, 255, 0.45)';
        ctx.fillRect(tileX + 6, tileY + 6, tileSize - 12, tileSize - 12);
        ctx.restore();
      }
      // Highlight selected factory
      if (selectedFactory && selectedFactory.x === x && selectedFactory.y === y) {
        ctx.fillStyle = 'rgba(0, 212, 255, 0.3)';
        ctx.fillRect(tileX, tileY, tileSize, tileSize);
      }

      if (grid[y][x] === COMPONENTS.FACTORY_NORMAL) {
        // Normal factory with gradient and glow
        const gradient = ctx.createRadialGradient(
          tileX + tileSize/2, tileY + tileSize/2, 5,
          tileX + tileSize/2, tileY + tileSize/2, 25
        );
        gradient.addColorStop(0, '#ff8e53');
        gradient.addColorStop(1, '#ff6b00');
        ctx.fillStyle = gradient;
        ctx.fillRect(tileX + 8, tileY + 8, tileSize - 16, tileSize - 16);
        
        // Add inner highlight
        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.fillRect(tileX + 12, tileY + 12, tileSize - 24, 8);
        
      } else if (grid[y][x] === COMPONENTS.FACTORY_CENTRAL) {
        // Central factory with red gradient and glow
        const gradient = ctx.createRadialGradient(
          tileX + tileSize/2, tileY + tileSize/2, 5,
          tileX + tileSize/2, tileY + tileSize/2, 25
        );
        gradient.addColorStop(0, '#e74c3c');
        gradient.addColorStop(1, '#c0392b');
        ctx.fillStyle = gradient;
        ctx.fillRect(tileX + 8, tileY + 8, tileSize - 16, tileSize - 16);
        
        // Add inner highlight
        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.fillRect(tileX + 12, tileY + 12, tileSize - 24, 8);
        
      } else if (grid[y][x] === COMPONENTS.COLLECTION) {
        // Collection box with animated glow
        const time = Date.now() * 0.005;
        const glowIntensity = (Math.sin(time) + 1) * 0.5;
        const gradient = ctx.createRadialGradient(
          tileX + tileSize/2, tileY + tileSize/2, 5,
          tileX + tileSize/2, tileY + tileSize/2, 30
        );
        gradient.addColorStop(0, `rgba(0, 255, 127, ${0.8 + glowIntensity * 0.2})`);
        gradient.addColorStop(1, `rgba(0, 200, 100, ${0.6 + glowIntensity * 0.2})`);
        ctx.fillStyle = gradient;
        ctx.fillRect(tileX + 5, tileY + 5, tileSize - 10, tileSize - 10);
      }

      // Grid lines with subtle glow
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
      ctx.lineWidth = 1;
      ctx.strokeRect(tileX, tileY, tileSize, tileSize);
    }
  }

  // Draw paths with enhanced graphics
  for (const pId in paths) {
    const path = paths[pId];
    if (!path || path.length < 2) continue;

    // Draw glow effect
    ctx.strokeStyle = 'rgba(0, 153, 255, 0.3)';
    ctx.lineWidth = 8;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    
    ctx.beginPath();
    for (let i = 0; i < path.length; i++) {
      const tile = path[i];
      const cx = tile.x * tileSize + tileSize / 2;
      const cy = tile.y * tileSize + tileSize / 2;
      if (i === 0) {
        ctx.moveTo(cx, cy);
      } else {
        ctx.lineTo(cx, cy);
      }
    }
    ctx.stroke();

    // Draw main path
    ctx.strokeStyle = '#00d4ff';
    ctx.lineWidth = 4;
    
    ctx.beginPath();
    for (let i = 0; i < path.length; i++) {
      const tile = path[i];
      const cx = tile.x * tileSize + tileSize / 2;
      const cy = tile.y * tileSize + tileSize / 2;
      if (i === 0) {
        ctx.moveTo(cx, cy);
      } else {
        ctx.lineTo(cx, cy);
      }
    }
    ctx.stroke();
  }
}

function hideCollectionIcon(){
  collectionIcon.parentElement.style.display = 'none';
  normalFactoryContainer.classList.remove('factory-hidden');
}

function showCentralFactory(){
  centralFactoryContainer.classList.remove('factory-hidden');
}

function drawCoins() {
  coins.forEach(coin => {
    if (!coin.active) return;
    const pos = coin.getDrawPosition();
    if (!pos) return;
    
    const factory = factories.find(f => f.id === coin.factoryId);
    const centerX = pos.x + tileSize / 2;
    const centerY = pos.y + tileSize / 2;
    
    // Pulsing glow effect
    const pulseSize = 3 + Math.sin(coin.pulsePhase) * 2;
    
    // Outer glow
    ctx.beginPath();
    const glowGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 15);
    if (factory.type === 'central') {
      glowGradient.addColorStop(0, 'rgba(255, 140, 0, 0.8)');
      glowGradient.addColorStop(1, 'rgba(255, 140, 0, 0)');
    } else {
      glowGradient.addColorStop(0, 'rgba(255, 221, 0, 0.8)');
      glowGradient.addColorStop(1, 'rgba(255, 221, 0, 0)');
    }
    ctx.fillStyle = glowGradient;
    ctx.arc(centerX, centerY, 15, 0, Math.PI * 2);
    ctx.fill();
    
    // Main coin
    ctx.beginPath();
    const coinGradient = ctx.createRadialGradient(centerX-2, centerY-2, 0, centerX, centerY, 8 + pulseSize);
    if (factory.type === 'central') {
      coinGradient.addColorStop(0, '#ffb347');
      coinGradient.addColorStop(1, '#ff8c00');
    } else {
      coinGradient.addColorStop(0, '#ffff66');
      coinGradient.addColorStop(1, '#ffd700');
    }
    ctx.fillStyle = coinGradient;
    ctx.arc(centerX, centerY, 8 + pulseSize, 0, Math.PI * 2);
    ctx.fill();
    
    // Inner highlight
    ctx.beginPath();
    ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
    ctx.arc(centerX - 2, centerY - 2, 3, 0, Math.PI * 2);
    ctx.fill();
  });
}

function spawnCoins() {
  if (paused) return;
  for (const f of factories) {
    const path = paths[f.id];
    if (path && path.length > 1) {
      if (playerPoints >= 0) {
        coins.push(new Coin(f.id));
      }
    }
  }
}

function update() {
  coins.forEach(c => {
    if (c.active) c.move();
  });
  coins = coins.filter(c => c.active);
}

function gameLoop() {
  if (!paused) {
    update();
    drawGrid();
    drawCoins();
  }
  requestAnimationFrame(gameLoop);
}

// Initialize game
normalFactoryContainer.classList.add('factory-hidden');
centralFactoryContainer.classList.add('factory-hidden');
updateCostsDisplay();
updateInfo();
gameLoop();
spawnCoins();
setInterval(spawnCoins, 1250); // spawn coins periodically



</script>
</body>
</html>

</html>



</script>
</body>
</html>
